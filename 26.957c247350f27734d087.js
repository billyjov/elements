(self.webpackChunk_angular_extensions_elements=self.webpackChunk_angular_extensions_elements||[]).push([[26],{1026:(e,n,t)=>{"use strict";t.r(n),t.d(n,{ChangeDetectionModule:()=>u});var o=t(9015),a=t(2309),i=t(3337),r=t(5366);let s=(()=>{class e{constructor(){this.codeExampleShareNgZone=l}ngOnInit(){}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["demo-change-detection"]],decls:49,vars:1,consts:[[1,"wrapper"],[3,"highlight"],["href","https://github.com/angular/angular/issues/31870","target","_blank"]],template:function(e,n){1&e&&(r.TgZ(0,"div",0),r.TgZ(1,"h1"),r._uU(2,"Change detection"),r.qZA(),r.TgZ(3,"p"),r._uU(4," In this section we're going to curate and discuss various change detection related issues and lessons learned when using Angular Elements. "),r.qZA(),r.TgZ(5,"h2"),r._uU(6," RxJs stream runs in a wrong (parent / outer) zone.js [Angular Elements] "),r.qZA(),r.TgZ(7,"h3"),r._uU(8,"Description"),r.qZA(),r.TgZ(9,"p"),r._uU(10," This issue happens when using "),r.TgZ(11,"code"),r._uU(12,"@angular/element"),r.qZA(),r._uU(13," inside of a parent Angular application. The parent application and element will NOT run in the same zone. This will lead to problems with change detection inside of the element when the "),r.TgZ(14,"code"),r._uU(15,"rxjs"),r.qZA(),r._uU(16," stream was triggered by the change of the "),r.TgZ(17,"code"),r._uU(18,"@Input() prop"),r.qZA(),r._uU(19," originating in the parent application. "),r.qZA(),r.TgZ(20,"p"),r._uU(21," The stream will run in parent zone (instead of element zone) so any async operation (like backend request or using "),r.TgZ(22,"code"),r._uU(23,"debounceTime()"),r.qZA(),r._uU(24," operator) will not trigger change detection of the element so the stream data will not be rendered... "),r.qZA(),r.TgZ(25,"h3"),r._uU(26,"Solution"),r.qZA(),r.TgZ(27,"ol"),r.TgZ(28,"li"),r._uU(29," Do NOT use "),r.TgZ(30,"code"),r._uU(31,"zone.js"),r.qZA(),r._uU(32," in your Angular element and trigger change detection manually "),r.qZA(),r.TgZ(33,"li"),r._uU(34," Use single (parent) "),r.TgZ(35,"code"),r._uU(36,"NgZone"),r.qZA(),r._uU(37," also for both the application and the element. "),r._UZ(38,"pre",1),r.qZA(),r.TgZ(39,"li"),r._uU(40," Use "),r.TgZ(41,"code"),r._uU(42,"import 'zone.js/dist/zone-patch-rxjs';"),r.qZA(),r._uU(43," in your Angular element. This will fix it BUT if the parent application (or ANY other lib used by the parent application) already has this import then the one in the element will be ignored and hence not solving the problem. "),r.qZA(),r.qZA(),r.TgZ(44,"p"),r._uU(45," Check out detailed description of the "),r.TgZ(46,"a",2),r._uU(47,"issue"),r.qZA(),r._uU(48," and some of the proposed solutions... "),r.qZA(),r.qZA()),2&e&&(r.xp6(38),r.Q6J("highlight",n.codeExampleShareNgZone))},directives:[o.y$],styles:["h2[_ngcontent-%COMP%]{margin:40px 0 10px}h2[_ngcontent-%COMP%], h3[_ngcontent-%COMP%]{font-weight:700}h3[_ngcontent-%COMP%]{margin:20px 0 5px}ol[_ngcontent-%COMP%]{margin:0 0 20px}.responsive-large[_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%], .responsive-large   [_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{width:70%}"]}),e})();const l="// in parent app (app.module.ts)\nexport class AppModule {\n  constructor(private ngZone: NgZone) {\n    (window as any).ngZone = this.ngZone // store ngZone reference on the window object\n  }\n}\n\n// in element (main.ts)\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule, { ngZone: (window as any).ngZone }) // use parent ngZone\n",g=[{path:"",component:s}];let p=(()=>{class e{}return e.\u0275fac=function(n){return new(n||e)},e.\u0275mod=r.oAB({type:e}),e.\u0275inj=r.cJS({imports:[[i.Bz.forChild(g)],i.Bz]}),e})(),u=(()=>{class e{}return e.\u0275fac=function(n){return new(n||e)},e.\u0275mod=r.oAB({type:e}),e.\u0275inj=r.cJS({imports:[[o._l,a.m,p]]}),e})()}}]);