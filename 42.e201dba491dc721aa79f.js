(self.webpackChunk_angular_extensions_elements=self.webpackChunk_angular_extensions_elements||[]).push([[42],{4042:(e,t,n)=>{"use strict";n.r(t),n.d(t,{HowItWorksModule:()=>m});var o=n(3337),a=n(9015),r=n(2309),i=n(5366);let l=(()=>{class e{constructor(){this.codeExampleComponent=s,this.codeExampleComponentBinding=d,this.codeExampleComponentLazy=u}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=i.Xpm({type:e,selectors:[["demo-how-it-works"]],decls:175,vars:3,consts:[[1,"wrapper"],["routerLink","../../use-cases"],["href","https://angular.io/guide/elements","target","_blank"],["href","https://github.com/manfredsteyer/ngx-build-plus#readme","target","_blank"],[1,"large"],[3,"highlight"]],template:function(e,t){1&e&&(i.TgZ(0,"div",0),i.TgZ(1,"h1"),i._uU(2,"How it works"),i.qZA(),i.TgZ(3,"p"),i._uU(4," The "),i.TgZ(5,"code"),i._uU(6,"*axLazyElement"),i.qZA(),i._uU(7," directive is used to load any Angular element (or any other web component) and display it in the standard Angular component template. "),i.qZA(),i.TgZ(8,"blockquote"),i._uU(9," In case you are wondering about when this approach might be useful please check out "),i.TgZ(10,"a",1),i._uU(11,"use cases"),i.qZA(),i._uU(12," page to learn more... "),i.qZA(),i.TgZ(13,"h2"),i._uU(14,"Angular elements"),i.qZA(),i.TgZ(15,"blockquote"),i._uU(16," Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way - "),i.TgZ(17,"a",2),i._uU(18,"Official Angular Docs"),i.qZA(),i.qZA(),i.TgZ(19,"p"),i._uU(20," As written in the official Angular documentation, Angular elements "),i.TgZ(21,"code"),i._uU(22,"@angular/elements"),i.qZA(),i._uU(23," provide us with a way to convert standard Angular components to custom elements (web components) which then can be consumed as standard built-in HTML elements from the point of view of the consumer application. "),i.qZA(),i.TgZ(24,"p"),i._uU(25," The elements can be built with the help of Angular CLI and "),i.TgZ(26,"code"),i._uU(27,"ngx-build-plus"),i.qZA(),i.TgZ(28,"a",3),i._uU(29,"library"),i.qZA(),i._uU(30," into single a bundle. Having a single bundle file makes it very convenient to consume custom Angular element in the consumer app! "),i.qZA(),i.TgZ(31,"h2"),i._uU(32," Standard way of using Angular elements (and other web components) in Angular applications "),i.qZA(),i.TgZ(33,"p"),i._uU(34," Let's say we have created an Angular element, for example "),i.TgZ(35,"code"),i._uU(36,"<your-org-customer-editor></your-org-customer-editor>"),i.qZA(),i._uU(37," and built and packaged it into a single bundle file "),i.TgZ(38,"code"),i._uU(39,"your-org-customer-editor.js"),i.qZA(),i._uU(40,". "),i.qZA(),i.TgZ(41,"p"),i._uU(42," Usually we would have to include "),i.TgZ(43,"code"),i._uU(44,'<script src="path/to/your-org-customer-editor.js"><\/script>'),i.qZA(),i._uU(45," in our "),i.TgZ(46,"code"),i._uU(47,"index.html"),i.qZA(),i._uU(48," so that we can be sure that the element loads before it was used in the template of some component of our consumer app. "),i.qZA(),i.TgZ(49,"p"),i._uU(50," This approach has "),i.TgZ(51,"strong"),i._uU(52,"one main disadvantage"),i.qZA(),i._uU(53,', which is that it increases initial javascript payload that needs to be downloaded, parsed and executed... Initial payload hurts even more if we\'re dealing with "sub-application" style Angular elements which can be considerably more complex compared to single components like button or card. '),i.qZA(),i.TgZ(54,"p"),i._uU(55," Initial loading time can make huge impact on overall success of many kind of applications and represents the main reason for existence of this library which enables us to "),i.TgZ(56,"strong"),i._uU(57,"lazy load Angular elements"),i.qZA(),i._uU(58," with ease and highest possible granularity! "),i.qZA(),i.TgZ(59,"h2"),i._uU(60," Much Better Way of using Angular elements (and other web components) "),i.qZA(),i.TgZ(61,"p"),i._uU(62," Wouldn't it be better if we could use our elements in the same way as any other HTML element while postpone their loading from some backend until the very last moment possible? "),i.qZA(),i.TgZ(63,"p"),i._uU(64," More so, wouldn't it be great if this happened automatically without the need to manually trigger some kind of loading of the necessary bundle? "),i.qZA(),i.TgZ(65,"blockquote",4),i._uU(66," What if all these things could be achieved by using simple structural directive "),i.TgZ(67,"code"),i._uU(68,"*axLazyElement"),i.qZA(),i._uU(69,"? "),i.qZA(),i._UZ(70,"pre",5),i.TgZ(71,"p"),i._uU(72," The "),i.TgZ(73,"code"),i._uU(74,"*axLazyElement"),i.qZA(),i._uU(75," is a structural directive which means it will "),i.TgZ(76,"strong"),i._uU(77,"remove"),i.qZA(),i._uU(78," the element on which it was added from the DOM by default. This is very useful because we DO NOT want to render element before it was actually loaded from the backend! The directive will then trigger loading of the bundle and the render element once the loading was finished. "),i.qZA(),i.TgZ(79,"h2"),i._uU(80,"Using standard Angular template binding"),i.qZA(),i.TgZ(81,"p"),i._uU(82," Another great thing about using this approach is that we can use standard Angular template binding syntax like "),i.TgZ(83,"code"),i._uU(84,'[customerId]="customerId"'),i.qZA(),i._uU(85," and "),i.TgZ(86,"code"),i._uU(87,'(customerDataChange)="handleCustomerDataChange($event)"'),i.qZA(),i._uU(88," to pass in data and react to events. It works just as expected even though the element is lazy loaded! "),i.qZA(),i._UZ(89,"pre",5),i.TgZ(90,"h2"),i._uU(91,"Seamless lazy loading"),i.qZA(),i.TgZ(92,"p"),i._uU(93," As mentioned above, our goal is to lazy load element to improve application startup time by decreasing size of javascript which has to be downloaded initially. "),i.qZA(),i.TgZ(94,"p"),i._uU(95," Lazy loading with "),i.TgZ(96,"code"),i._uU(97,"*axLazyElements"),i.qZA(),i._uU(98," happens automatically whenever the element is rendered in the template of some Angular component. Consider the following example... "),i.qZA(),i._UZ(99,"pre",5),i.TgZ(100,"p"),i._uU(101," We're using "),i.TgZ(102,"code"),i._uU(103,'<your-org-customer-editor *axLazyElement="url"></your-org-customer-editor>'),i.qZA(),i._uU(104," in the components template but it will not trigger element loading just yet. As we may notice, the element is wrapped in the "),i.TgZ(105,"code"),i._uU(106,"<ng-container></ng-container>"),i.qZA(),i._uU(107," which uses "),i.TgZ(108,"code"),i._uU(109,"*ngIf"),i.qZA(),i._uU(110," directive so our element is not rendered until we click the button... "),i.qZA(),i.TgZ(111,"blockquote",4),i._uU(112," The loading of the element will be triggered only after we have clicked the button and rendered it in the component template "),i.qZA(),i.TgZ(113,"p"),i._uU(114," To summarize, the element loading will be postponed until it was rendered in the template of some component. This can happen in following cases... "),i.qZA(),i.TgZ(115,"ul"),i.TgZ(116,"li"),i._uU(117,"Angular component uses element in its template"),i.qZA(),i.TgZ(118,"li"),i._uU(119," Angular component uses element in its template conditionally ("),i.TgZ(120,"code"),i._uU(121,"*ngIf"),i.qZA(),i._uU(122,", "),i.TgZ(123,"code"),i._uU(124,"*ngFor"),i.qZA(),i._uU(125,", ...) and the condition was fulfilled "),i.qZA(),i.TgZ(126,"li"),i._uU(127," User navigated to an Angular component which uses element in its template (can be both eagerly or lazily loaded routes) "),i.qZA(),i.qZA(),i.TgZ(128,"blockquote"),i._uU(129," This also means that if we used element in a component that is displayed straight from application startup, we would also trigger loading of the element bundle immediately so it will "),i.TgZ(130,"strong"),i._uU(131,"NOT be lazy"),i.qZA(),i._uU(132," in that case "),i.qZA(),i.TgZ(133,"h2"),i._uU(134,"In-depth overview of loading mechanism"),i.qZA(),i.TgZ(135,"p"),i._uU(136," Loading starts only once we want to display an Angular component which renders given element in its template. After that the loading goes through the following process "),i.qZA(),i.TgZ(137,"ol"),i.TgZ(138,"li"),i._uU(139," Check if we provided reference to "),i.TgZ(140,"code"),i._uU(141,"loading"),i.qZA(),i._uU(142," template ("),i.TgZ(143,"code"),i._uU(144,"<ng-template #loading>Loading ...</ng-template>"),i.qZA(),i._uU(145,") and display it in place of the element... "),i.qZA(),i.TgZ(146,"li"),i._uU(147,"Check if element was already loaded in the past"),i.qZA(),i.TgZ(148,"li"),i._uU(149,"\u2705 If yes, remove loading template and render given element instead"),i.qZA(),i.TgZ(150,"li"),i._uU(151," \u2b07\ufe0f If no, create a "),i.TgZ(152,"code"),i._uU(153,"<script>"),i.qZA(),i._uU(154," tag with "),i.TgZ(155,"code"),i._uU(156,"src = url"),i.qZA(),i._uU(157," and handler for the "),i.TgZ(158,"code"),i._uU(159,"onload"),i.qZA(),i._uU(160," and "),i.TgZ(161,"code"),i._uU(162,"onerror"),i.qZA(),i._uU(163," events to notify directive when element was loaded or failed to load "),i.qZA(),i.TgZ(164,"li"),i._uU(165,"Append "),i.TgZ(166,"code"),i._uU(167,"<script>"),i.qZA(),i._uU(168," to the document body"),i.qZA(),i.TgZ(169,"li"),i._uU(170,"Once loaded, notify directive about the outcome"),i.qZA(),i.TgZ(171,"li"),i._uU(172," \u2705 Remove loading template and render given element when loading was successful "),i.qZA(),i.TgZ(173,"li"),i._uU(174," \u274c Remove loading template and render error template (if provided) when loading was not successful "),i.qZA(),i.qZA(),i.qZA()),2&e&&(i.xp6(70),i.Q6J("highlight",t.codeExampleComponent),i.xp6(19),i.Q6J("highlight",t.codeExampleComponentBinding),i.xp6(10),i.Q6J("highlight",t.codeExampleComponentLazy))},directives:[o.yS,a.y$],styles:["ol[_ngcontent-%COMP%]{margin:0 0 20px}h2[_ngcontent-%COMP%]{margin:40px 0 10px;font-weight:700}.responsive-large[_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%], .responsive-large   [_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{width:70%}"]}),e})();const s="import { Component } from '@angular/core';\n\n@Component({\n  selector: 'your-org-feature',\n  template: `\n    <your-org-customer-editor *axLazyElement=\"url\"></your-org-customer-editor>\n  `\n})\nexport class FeatureComponent {\n  url = 'path/to/your-org-customer-editor.js';\n}\n",u="import { Component } from '@angular/core';\n\n@Component({\n  selector: 'your-org-feature',\n  template: `\n    <ng-container *ngIf=\"showEditor\">\n      <your-org-customer-editor *axLazyElement=\"url\"></your-org-customer-editor>\n    </ng-container>\n    <button (click)=\"toggleShowEditor()\">Edit customer</button>\n  `\n})\nexport class FeatureComponent {\n  showEditor = false;\n\n  url = 'path/to/your-org-customer-editor.js';\n\n  toggleShowEditor() {\n    this.showEditor = !showEditor;\n  }\n}\n",d="import { Component } from '@angular/core';\n\n@Component({\n  selector: 'your-org-feature',\n  template: `\n    <your-org-customer-editor *axLazyElement=\"url\"\n      [customerId]=\"customerId\"\n      (customerDataChange)=\"handleCustomerDataChange($event)\">\n    </your-org-customer-editor>\n  `\n})\nexport class FeatureComponent {\n  url = 'path/to/your-org-customer-editor.js';\n\n  customerId = 'C-123-456';\n\n  handleCustomerDataChange(change) {\n    // handle change ...\n  }\n}\n",g=[{path:"",component:l}];let c=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=i.oAB({type:e}),e.\u0275inj=i.cJS({imports:[[o.Bz.forChild(g)],o.Bz]}),e})(),m=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=i.oAB({type:e}),e.\u0275inj=i.cJS({imports:[[o.Bz,a._l,r.m,c]]}),e})()}}]);